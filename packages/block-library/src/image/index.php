<?php
/**
 * core/image block.
 */

/**
 * Warm the object cache with post and meta information for all found
 * image blocks to avoid making individual database calls
 * (similarly to `wp_make_content_images_responsive()`).
 *
 * @access private
 * @since 4.2
 *
 * @param string $content The post content.
 * @return string $content Unchanged post content.
 */
function _gutenberg_cache_images_meta( $content ) {
	// Need to find all image blocks and get the attachment IDs from them BEFORE the parser is run
	// so we can get the image attachments meta all at once from the DB.
	if ( preg_match_all( '/^<!-- wp:image {.*"id":(\d+),.*} -->$/m', $content, $matches ) ) {
		_prime_post_caches( $matches[1], false, true );
	}

	return $content;
}

// Run before blocks are parsed.
add_filter( 'the_content', '_gutenberg_cache_images_meta', 5 );

/**
 * Get the expected block width from the global $block_width array.
 *
 * The global $block_width array is expectd to be set by the theme for each block container.
 * It should contain three values: default, wide and full, in pixels.
 * - The `default` value should be the expected block width (similarly to $content_width).
 * - The `wide` value is optional and is used when the block alignment is set to `wide`.
 * - Similarly the `full` value is optional and used then the alignment is set to `full`.
 * If `wide` and `full` are not set, the `default` value is used instead.
 *
 * Example:
 *     $GLOBALS['block_width'] = array(
 *         'default' => 640,
 *         'wide'    => 800,
 *         'full'    => 1024,
 *     );
 *
 * In addition the $block_width array should be set contextually for each block container.
 * For example: in the main content column the `default` width will be something like 640(px),
 * but for a sidebar it would be something like 250.
 *
 * @since 4.2.0
 *
 * @return array Normalized array of expected block width with three elements: `default`, `wide`, and `full`.
 */
function gutenberg_get_block_width() {
	global $content_width, $block_width;

	// Get the width from the $block_width global array
	// or fall back to using $content_width.
	if ( empty( $block_width ) || ! is_array( $block_width ) || empty( $block_width['default'] ) ) {
		if ( empty( $content_width ) ) {
			$default_width = 1024; // Fall back to the "large" image file width.
		} else {
			$default_width = $content_width;
		}

		$width = array(
			'default' => $default_width,
			'wide' => $default_width,
			'full' => $default_width,
		);
	} else {
		$width = $block_width;

		if ( empty( $width['wide'] ) ) {
			$width['wide'] = $width['default'];
		}

		if ( empty( $width['full'] ) ) {
			$width['full'] = $width['default'];
		}
	}

	return $width;
}

/**
 * Calculates the image width and height based on $block_witdh and the `scale` block attribute.
 *
 * @since 4.2.0
 *
 * @param array $block_attributes The block attributes.
 * @param array $image_meta Optional. The image attachment meta data.
 * @return array|bool An array of the image width and height, in that order, or false if the image data is missing from $block_attributes.
 */
function gutenberg_get_image_width_height( $block_attributes, $image_meta = null ) {
	$block_witdh = gutenberg_get_block_width();

	if ( empty( $block_attributes['fileWidth'] ) || empty( $block_attributes['fileHeight'] ) ) {
		if ( ! empty( $block_attributes['width'] ) && ! empty( $block_attributes['height'] ) ) {
			// Old post with an image that was resized?
			return array(
				$block_attributes['width'],
				$block_attributes['height'],
			);
		} else {
			// Image data is missing.
			return false;
		}
	} else {
		$image_file_width = (int) $block_attributes['fileWidth'];
		$image_file_height = (int) $block_attributes['fileHeight'];
	}

	if ( ! empty( $image_meta ) &&
		$image_file_width < $image_meta['width'] &&
		! empty( $image_meta['sizes']['large'] ) &&
		$image_file_width === (int) $image_meta['sizes']['large']['width'] &&
		wp_image_matches_ratio( $image_file_width, $image_file_height, $image_meta['width'], $image_meta['height'] )
	) {
		// TODO: To reduce (fix) the need for upscaling or using the "full" size
		// add `xlarge` image size generated by default!!
		// Photos taken with modern phones and cameras are usually several megabytes in size, can be over 8MB in some cases.
		// That makes the "full" image size not suitable for web use.
		// Do not constrain images with `wide` and `full` allignment to the "large" image size.
		// Sometimes need to use a larger image there, if one exists.
		// Note: there is a constrain on the largest image size in the srcset attribute, see `wp_calculate_image_srcset()`.
		$full_file_width = (int) $image_meta['width'];
	} else {
		$full_file_width = $image_file_width;
	}

	if ( $block_attributes['align'] === 'full' ) {
		$image_width = min( (int) $block_witdh['full'], $full_file_width );
	} elseif ( $block_attributes['align'] === 'wide' ) {
		$image_width = min( (int) $block_witdh['wide'], $full_file_width );
	} else {
		$image_width = (int) $block_witdh['default'];

		if ( ! empty( $block_attributes['width'] ) && ! empty( $block_attributes['editWidth'] ) ) {
			// Scale the image if it was resized in the editor.
			$scale = $block_attributes['width'] / $block_attributes['editWidth'];
			// TODO: allow upscaling? Looks ugly, but someone may expect it?
			$image_width = round( $image_width * $scale );
		}

		$image_width = min( $image_width, $image_file_width );
	}

	// Recalculate.
	$image_size = wp_constrain_dimensions( $image_file_width, $image_file_height, $image_width );

	/**
	 * Filters the calculated image size for the image block.
	 *
	 * @since 4.2.0
	 *
	 * @param array $image_size The calculated image size width and height (in that order).
	 * @param array $block_attributes The block attributes.
	 * @param array $image_meta The image attachment meta data.
	 */
	return apply_filters( 'gutenberg_get_image_width_height', $image_size, $block_attributes, $image_meta );
}

function render_block_core_image( $block_attributes = array(), $html = '' ) {
	// Old post or... something's wrong.
	if ( empty( $html ) || empty( $block_attributes ) ) {
		return $html;
	}

	$image_src = '';
	$attachment_id = 0;
	$image_meta = null;
	$srcset = '';
	$sizes = '';

	// Local image
	if ( ! empty( $block_attributes['id'] ) ) {
		$attachment_id = (int) $block_attributes['id'];
		$image_meta = wp_get_attachment_metadata( $attachment_id );

		// Broken or very old image meta? Incorrect attachment id?
		if ( empty( $image_meta['height'] ) || empty( $image_meta['width'] ) ) {
			return $html;
		}

		if ( empty( $block_attributes['url'] ) ) {
			// Old post. Proceed if the full size image was used (default old behavior).
			$attachment_url = wp_get_attachment_url( $attachment_id );

			if ( strpos( $html, ' src="' . $attachment_url . '"' ) !== false ) {
				// If the full size image was used, attempt to use the large size, if it has the same ratio.
				if ( ! empty( $image_meta['sizes']['large'] ) ) {
					$large = $image_meta['sizes']['large'];

					if ( wp_image_matches_ratio( $large['width'], $large['height'], $image_meta['width'], $image_meta['height'] ) ) {
						$image_data = wp_get_attachment_image_src( $attachment_id, 'large', false );

						// Can be `false`.
						if ( $image_data ) {
							$block_attributes['url'] = $image_data[0];
							// wp_get_attachment_image_src() calls image_downsize()
							// which calls image_constrain_size_for_editor() which may reduce the actual file size.
							// We want the "real" size.
							$block_attributes['fileWidth'] = $large['width'];
							$block_attributes['fileHeight'] = $large['height'];
						}
					}
				} else {
					$block_attributes['url'] = $attachment_url;
				}
			} else {
				// If the full size wasn't used, fall back to the existing HTML.
				return $html;
			}
		}
	}

	if ( ! empty( $block_attributes['userWidth'] ) && ! empty( $block_attributes['userHeight'] ) ) {
		// The user has set specific width and height. Honor them.
		$image_dimensions = array(
			$block_attributes['userWidth'],
			$block_attributes['userHeight'],
		);
	} else {
		$image_dimensions = gutenberg_get_image_width_height( $block_attributes, $image_meta );
	}

	if ( empty( $image_dimensions ) || empty( $block_attributes['url'] ) ) {
		// We don't have enough data to construct new img tag.
		// Fall back to the existing HTML.
		return $html;
	}

	$image_src = $block_attributes['url'];

	$image_attributes = array(
		'src' => $image_src,
		'alt' => empty( $block_attributes['alt'] ) ? '' : $block_attributes['alt'],
		'width' => $image_dimensions[0],
		'height' => $image_dimensions[1],
	);

	if ( $image_meta ) {
		// TODO: add another param so we can pass `$block_attributes` to the filter.
		$srcset = wp_calculate_image_srcset( $image_dimensions, $image_src, $image_meta, $attachment_id );

		if ( ! empty( $srcset ) ) {
			// TODO: add another param so we can pass `$block_attributes` to the filter.
			// This will let themes generate much better `sizes` attribute.
			$sizes = wp_calculate_image_sizes( $image_dimensions, $image_src, $image_meta, $attachment_id );
		}

		if ( $srcset && $sizes ) {
			$image_attributes['srcset'] = $srcset;
			$image_attributes['sizes'] = $sizes;
		}
	}

	/**
	 * Filters the image tag attributes when rendering the core image block.
	 *
	 * @since 4.0
	 *
	 * @param array $image_attributes The (recalculated) image attributes.
	 *                                Note: expects valid HTML 5.0 attribute names.
	 * @param array $block_attributes The image block attributes.
	 * @param string $html The image block HTML coming from the editor. The img tag will be replaced.
	 */
	$image_attributes = apply_filters( 'render_block_core_image_tag_attributes', $image_attributes, $block_attributes, $html );

	$attr = '';
	foreach ( $image_attributes as $name => $value ) {
		// Sanitize for valid HTML 5.0 attribute names, see: https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes.
		$name = preg_replace( '/[^a-z0-9-]+/', '', strtolower( $name ) );

		if ( empty( $name ) ) {
			continue;
		}

		if ( 'src' === $name ) {
			$value = esc_url( $value );
		} elseif ( ( 'width' === $name || 'height' === $name ) && ! empty( $value ) ) {
			$value = (int) $value;
		} else {
			$value = esc_attr( $value );
		}

		$attr .= sprintf( ' %s="%s"', $name, $value );
	}

	$image_tag = '<img' . $attr . '/ >';

	// Replace the img tag.
	$html = preg_replace( '/<img [^>]+>/', $image_tag, $html );

	return $html;
}

function register_block_core_image() {
	register_block_type(
		'core/image',
		array(
			'attributes' => array(
				'className' => array(
					'type' => 'string', // Any custom class name(s) the user has entered.
				),
				'url' => array(
					'type' => 'string', // The img src.
				),
				'alt' => array(
					'type' => 'string',
				),
				'id' => array(
					'type' => 'number',
				),
				'align' => array(
					'type' => 'string',
					'enum' => array( 'center', 'left', 'right', 'wide', 'full', '' ),
				),
				'width' => array(
					'type' => 'number',
				),
				'height' => array(
					'type' => 'number',
				),
				'fileWidth' => array(
					'type' => 'number',
				),
				'fileHeight' => array(
					'type' => 'number',
				),
				'userWidth' => array(
					'type' => 'number',
				),
				'userHeight' => array(
					'type' => 'number',
				),
				'editWidth' => array(
					'type' => 'number',
				),

				/* These are not stored in the block attributes, but can be added.
				'srcSet' => array(
					'type' => 'string',
				),
				'sizes' => array(
					'type' => 'string',
				),
				*/
			),
			'render_callback' => 'render_block_core_image',
		)
	);
}

add_action( 'init', 'register_block_core_image' );
